import os
import sys
os.environ['CUDA_VISIBLE_DEVICES'] = '-1'
#os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'



import tensorflow as tf
import numpy as np
from skimage.measure import compare_psnr as psnr
from skimage.measure import compare_ssim as ssim
from morph_layers import *
from generator_gray import *
from  models_gray import *


def save_models(model_list,path="./models/"):
    model_name=["model_path1.h5","model_path2.h5","model_path12.h5","model_cnn.h5","model12_new.h5","model_morph_type2.h5"]
    for i in range(len(model_list)):
        model_list[i].save_weights(path+model_name[i])


def get_model_list():
    model_cnn=create_CNN_model()
    model_path1=path1_old()
    model_path2=path2_old()
    model_path12=path12_old()
    model_path12_new=create_morph_path12_model()
    model_morph_type2=create_morph_model_type2()

    model_list=[model_path1,model_path2,model_path12,model_cnn,model_path12_new,model_morph_type2]
    return model_list




def get_trained_models(path="./models/"):
    model_list=get_model_list()
    model_name=["model_path1.h5","model_path2.h5","model_path12.h5","model_cnn.h5","model12_new.h5","model_morph_type2.h5"]

    for i in range(len(model_list)):
        print i
        model_list[i].load_weights(path+model_name[i])

    return model_list






def read_resize_image(file_path):
    Img = misc.imread(file_path)
    #print Img.shape
    #Img = rgb2gray(Img)/255.0
    Img = resize(Img, (512,512,3))

    return Img




def read_files(file_in,file_out):

    images_in=[]
    images_out=[]
    print"getting all the images..."
    for f1,f2 in zip(file_in,file_out):
        img1=read_resize_image(f1)
        img2=read_resize_image(f2)
        img1=rgb2gray(img1)
        img2=rgb2gray(img2)


        images_in.append(img1) 
        images_out.append(img2) 

    images_in=np.array(images_in,dtype="float32")
    images_out=np.array(images_out,dtype="float32")

    images_in=images_in[:,:,:,np.newaxis]
    images_out=images_out[:,:,:,np.newaxis]
    return images_in,images_out



def calculate_score(Y_out,Y_gt):
    Y_out=Y_out[:,:,:,0] 
    Y_gt=Y_gt[:,:,:,0] 

    Score=[]
    print("computing  Score")
    for i in range(Y_out.shape[0]):
        t1=psnr(Y_out[i],Y_gt[i])
        #t2=ssim(Y_out[i],Y_gt[i],multichannel=True)
        t2=ssim(Y_out[i],Y_gt[i])     #consder single channel since gray scale
        Score.append([t1,t2])

    Score=np.array(Score)
    Score=np.mean(Score,axis=0)
    return  Score   




###########MAIN TEST CODE###########################################################################


model_list=get_trained_models()


file_in,file_out=get_in_out_file_test()
X,Y_gt=read_files(file_in,file_out)

S=[]
score=calculate_score(X,Y_gt)
S.append(score)

for model in model_list:
    Y_out=model.predict(X,batch_size=128)
    Y_out=np.clip(Y_out,0,1)
    score=calculate_score(Y_out,Y_gt)
    S.append(score)


print S
